import { writeFile, mkdir } from 'fs/promises';
import { dirname } from 'path';
import type { FullResult } from '@playwright/test/reporter';
import type { FairReporterConfig, TestMetadata } from '../types/index.js';

/**
 * AI-optimized markdown formatter
 */
export class AIFormatter {
  private config: Required<FairReporterConfig>;
  private outputPath: string;

  constructor(config: Required<FairReporterConfig>, outputPath: string) {
    this.config = config;
    this.outputPath = outputPath;
  }

  async write(allTests: TestMetadata[], result: FullResult): Promise<void> {
    const markdown = this.generateMarkdown(allTests, result);

    try {
      // Ensure directory exists
      await mkdir(dirname(this.outputPath), { recursive: true });

      // Write file
      await writeFile(this.outputPath, markdown, 'utf-8');
    } catch (error) {
      console.error(`Failed to write AI summary: ${error}`);
    }
  }

  private generateMarkdown(allTests: TestMetadata[], result: FullResult): string {
    const passed = allTests.filter((t) => t.status === 'passed').length;
    const failed = allTests.filter((t) => t.status === 'failed').length;
    const skipped = allTests.filter((t) => t.status === 'skipped').length;
    const totalDuration = allTests.reduce((sum, t) => sum + (t.duration || 0), 0);

    const overallStatus = failed > 0 ? 'âŒ FAILED' : 'âœ… PASSED';

    let md = `# Test Results\n\n`;
    md += `**Status**: ${overallStatus} (${passed}/${allTests.length} tests passed)\n`;
    md += `**Duration**: ${(totalDuration / 1000).toFixed(2)}s\n`;
    md += `**Date**: ${new Date().toISOString()}\n\n`;

    md += `## Summary\n\n`;
    md += `- âœ… Passed: ${passed}\n`;
    md += `- âŒ Failed: ${failed}\n`;
    md += `- âŠ˜ Skipped: ${skipped}\n`;
    md += `- ðŸ“Š Total: ${allTests.length}\n\n`;

    // Failed tests (detailed)
    const failedTests = allTests.filter((t) => t.status === 'failed');
    if (failedTests.length > 0) {
      md += `## âŒ Failed Tests\n\n`;
      failedTests.forEach((test) => {
        md += `### ${test.title}\n\n`;
        md += `**File**: \`${test.file}\`\n`;
        md += `**Duration**: ${test.duration}ms\n\n`;

        if (test.error) {
          md += `**Error**: ${test.error.message}\n\n`;
          if (test.error.location) {
            md += `**Location**: \`${test.error.location}\`\n\n`;
          }
        }

        // Steps
        if (test.steps.length > 0) {
          md += `**Steps Executed**:\n\n`;
          test.steps.forEach((step, index) => {
            const icon = step.status === 'passed' ? 'âœ…' : step.status === 'failed' ? 'âŒ' : 'âŠ˜';
            const level = step.level === 'major' ? '**MAJOR**' : 'minor';
            const duration = step.duration ? ` (${step.duration}ms)` : '';
            md += `${index + 1}. ${icon} [${level}] ${step.title}${duration}\n`;

            if (step.status === 'failed' && step.error) {
              md += `   - Error: ${step.error.message}\n`;
            }
          });
          md += `\n`;
        }

        // Attachments
        if (test.attachments.length > 0) {
          md += `**Artifacts**:\n\n`;
          test.attachments.forEach((att) => {
            if (att.path) {
              md += `- ${att.name}: \`${att.path}\`\n`;
            }
          });
          md += `\n`;
        }

        md += `---\n\n`;
      });
    }

    // Passed tests (summary only if configured)
    if (this.config.compression.passedTests !== 'hide') {
      const passedTests = allTests.filter((t) => t.status === 'passed');
      if (passedTests.length > 0) {
        md += `## âœ… Passed Tests\n\n`;

        if (this.config.compression.passedTests === 'summary') {
          md += `All ${passedTests.length} test(s) passed:\n\n`;
          passedTests.forEach((test) => {
            md += `- ${test.title} (${test.duration}ms)\n`;
          });
          md += `\n`;
        } else {
          // Full details
          passedTests.forEach((test) => {
            md += `### ${test.title}\n\n`;
            md += `**Duration**: ${test.duration}ms\n\n`;
            if (test.steps.length > 0) {
              md += `**Steps**:\n\n`;
              test.steps.forEach((step, index) => {
                md += `${index + 1}. âœ… ${step.title} (${step.duration}ms)\n`;
              });
            }
            md += `\n`;
          });
        }
      }
    }

    // Skipped tests
    const skippedTests = allTests.filter((t) => t.status === 'skipped');
    if (skippedTests.length > 0) {
      md += `## âŠ˜ Skipped Tests\n\n`;
      skippedTests.forEach((test) => {
        md += `- ${test.title}\n`;
      });
      md += `\n`;
    }

    md += `---\n\n`;
    md += `*Generated by [fair-playwright](https://github.com/baranaytas/fair-playwright)*\n`;

    return md;
  }
}
